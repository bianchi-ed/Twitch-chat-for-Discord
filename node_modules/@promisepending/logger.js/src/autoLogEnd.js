"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.deactivate = exports.activate = void 0;
const logger_1 = require("./logger");
const util_1 = __importDefault(require("util"));
var exited = false;
var logger = null;
function exitHandler({ err, options, exitCode }) {
    if (!exited) {
        process.stdin.resume();
        exited = true;
        if (typeof exitCode === 'string') {
            logger === null || logger === void 0 ? void 0 : logger.warn('Manually Finished!');
        }
        else {
            if (exitCode !== 123654)
                logger === null || logger === void 0 ? void 0 : logger.info('Program finished, code: ' + exitCode);
            if (exitCode === 123654 && (options === null || options === void 0 ? void 0 : options.uncaughtException)) {
                logger === null || logger === void 0 ? void 0 : logger.fatal(util_1.default.format(typeof err === 'string' ? err : err === null || err === void 0 ? void 0 : err.stack));
                exitCode = 1;
            }
            else if (exitCode && exitCode === 123654) {
                logger === null || logger === void 0 ? void 0 : logger.error(util_1.default.format(typeof err === 'string' ? err : err === null || err === void 0 ? void 0 : err.stack));
                logger === null || logger === void 0 ? void 0 : logger.warn('#===========================================================#');
                logger === null || logger === void 0 ? void 0 : logger.warn('| # AutoLogEnd prevent program exit!');
                logger === null || logger === void 0 ? void 0 : logger.warn('| # Code that is not async or would be runned after the line that generated the error cannot run as per nodejs default behavior.');
                logger === null || logger === void 0 ? void 0 : logger.warn('| # But promises, async code and event based functions will still be executed.');
                logger === null || logger === void 0 ? void 0 : logger.warn('| # In order to prevent sync code to stop, use an try-catch or a promise.');
                logger === null || logger === void 0 ? void 0 : logger.warn('#===========================================================#');
                logger === null || logger === void 0 ? void 0 : logger.warn('If you want to manually exit, you can still use control-c in the process.');
                exited = false;
                return;
            }
        }
        process.exit(typeof exitCode === 'string' ? 0 : exitCode);
    }
}
function activate(uncaughtException, logger) {
    logger = logger !== null && logger !== void 0 ? logger : new logger_1.Logger({ prefix: 'SYSTEM' });
    logger === null || logger === void 0 ? void 0 : logger.debug('AutoLogEnd activated!');
    process.on('exit', (exitCode) => exitHandler({ exitCode, options: { uncaughtException: false } }));
    process.on('SIGINT', (error) => { exitHandler({ err: { message: error, name: null, stack: null }, options: { uncaughtException: false }, exitCode: 'SIGINT' }); });
    process.on('SIGUSR1', (error) => { exitHandler({ err: { message: error, name: null, stack: null }, options: { uncaughtException: false }, exitCode: 'SIGUSR1' }); });
    process.on('SIGUSR2', (error) => { exitHandler({ err: { message: error, name: null, stack: null }, options: { uncaughtException: false }, exitCode: 1 }); });
    process.on('SIGTERM', (error) => { exitHandler({ err: { message: error, name: null, stack: null }, options: { uncaughtException: false }, exitCode: 'SIGTERM' }); });
    process.on('uncaughtException', (error) => {
        exitHandler({
            err: { message: error.message, name: error.name, stack: error.stack },
            options: { uncaughtException: uncaughtException !== null && uncaughtException !== void 0 ? uncaughtException : false },
            exitCode: 123654,
        });
    });
}
exports.activate = activate;
function deactivate() {
    process.removeListener('exit', exitHandler);
    process.removeListener('SIGINT', exitHandler);
    process.removeListener('SIGUSR1', exitHandler);
    process.removeListener('SIGUSR2', exitHandler);
    process.removeListener('SIGTERM', exitHandler);
    process.removeListener('uncaughtException', exitHandler);
    logger === null || logger === void 0 ? void 0 : logger.debug('AutoLogEnd deactivated!');
}
exports.deactivate = deactivate;
