"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Logger = void 0;
const interfaces_1 = require("./interfaces");
const escape_html_1 = __importDefault(require("escape-html"));
const adm_zip_1 = __importDefault(require("adm-zip"));
const chalk_1 = __importDefault(require("chalk"));
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const util_1 = __importDefault(require("util"));
class Logger {
    constructor({ prefix, debug, defaultLevel, coloredBackground, disableFatalCrash, allLineColored, fileProperties }) {
        this.defaultLevel = interfaces_1.ELoggerLevel.LOG;
        this.debugActive = false;
        this.defaultHeader = '';
        this.prefix = prefix !== null && prefix !== void 0 ? prefix : '';
        this.debugActive = debug !== null && debug !== void 0 ? debug : false;
        this.defaultLevel = defaultLevel !== null && defaultLevel !== void 0 ? defaultLevel : interfaces_1.ELoggerLevel.INFO;
        this.coloredBackground = coloredBackground !== null && coloredBackground !== void 0 ? coloredBackground : false;
        this.disableFatalCrash = disableFatalCrash !== null && disableFatalCrash !== void 0 ? disableFatalCrash : false;
        this.allLineColored = allLineColored !== null && allLineColored !== void 0 ? allLineColored : false;
        this.htmlBackgroundColor = '#0a002b';
        this.htmlTextColor = '#ffffff';
        this.fileProperties = {
            enable: false,
            logFolderPath: path_1.default.join(__dirname, 'logs'),
            enableLatestLog: true,
            enableDebugLog: false,
            enableErrorLog: false,
            enableFatalLog: true,
            generateHTMLLog: false,
            compressLogFilesAfterNewExecution: true,
        };
        this.fileProperties = Object.assign(Object.assign({}, this.fileProperties), fileProperties !== null && fileProperties !== void 0 ? fileProperties : {});
        if (this.fileProperties.enable) {
            // create log folder if not exists
            if (!fs_1.default.existsSync(this.fileProperties.logFolderPath))
                fs_1.default.mkdirSync(this.fileProperties.logFolderPath);
            else
                this.compressLastSessionLogs();
            // creates folders for fatal-crash and latest logs
            if (!fs_1.default.existsSync(path_1.default.join(this.fileProperties.logFolderPath, 'fatal-crash')))
                fs_1.default.mkdirSync(path_1.default.join(this.fileProperties.logFolderPath, 'fatal-crash'));
            if (!fs_1.default.existsSync(path_1.default.join(this.fileProperties.logFolderPath, 'latestLogs')))
                fs_1.default.mkdirSync(path_1.default.join(this.fileProperties.logFolderPath, 'latestLogs'));
            // eslint-disable-next-line max-len
            this.defaultHeader = `<body style="--txtBackground: ${this.htmlBackgroundColor}; color: ${this.htmlTextColor}; background: ${this.htmlBackgroundColor}; margin: 0;padding: 0.25rem;display:flex;flex-direction:column;"><style>* {padding: 0.15rem 0;} body > span {position: relative;display: flex;flex-direction: row;} span > span {height: 100%;display: block;padding: 0;width: 100%;box-shadow: 0 0 0 0.16rem var(--txtBackground)} .pre {width: fit-content;white-space: nowrap;box-shadow: none;}</style>\n`;
            if (this.fileProperties.enableLatestLog) {
                this.latestFileStream = fs_1.default.createWriteStream(path_1.default.join(this.fileProperties.logFolderPath, `latest.${this.fileProperties.generateHTMLLog ? 'html' : 'log'}`), { flags: 'a' });
                if (this.fileProperties.generateHTMLLog)
                    this.latestFileStream.write(this.defaultHeader);
            }
            if (this.fileProperties.enableDebugLog) {
                this.debugLogStream = fs_1.default.createWriteStream(path_1.default.join(this.fileProperties.logFolderPath, 'latestLogs', `debug.${this.fileProperties.generateHTMLLog ? 'html' : 'log'}`), { flags: 'a' });
                if (this.fileProperties.generateHTMLLog)
                    this.debugLogStream.write(this.defaultHeader);
            }
            if (this.fileProperties.enableErrorLog) {
                this.errorLogStream = fs_1.default.createWriteStream(path_1.default.join(this.fileProperties.logFolderPath, 'latestLogs', `error.${this.fileProperties.generateHTMLLog ? 'html' : 'log'}`), { flags: 'a' });
                if (this.fileProperties.generateHTMLLog)
                    this.errorLogStream.write(this.defaultHeader);
            }
            // handles process exists to properly close the streams
            process.on('exit', (exitCode) => {
                // eslint-disable-next-line max-len
                this.closeFileStreams(`${this.fileProperties.generateHTMLLog ? '<br>\n<span>' : '\n'}Process exited with code (${exitCode})${this.fileProperties.generateHTMLLog ? '</span>\n<br>' : '\n'}`);
            });
        }
        else {
            this.fileProperties.enableLatestLog = false;
            this.fileProperties.enableDebugLog = false;
            this.fileProperties.enableErrorLog = false;
            this.fileProperties.enableFatalLog = false;
            this.fileProperties.generateHTMLLog = false;
            this.fileProperties.compressLogFilesAfterNewExecution = false;
        }
    }
    closeFileStreams(closeStreamMessage, customFatalMessage) {
        var _a, _b, _c;
        this.writeToAllStreams(closeStreamMessage !== null && closeStreamMessage !== void 0 ? closeStreamMessage : '', customFatalMessage);
        (_a = this.latestFileStream) === null || _a === void 0 ? void 0 : _a.end();
        (_b = this.debugLogStream) === null || _b === void 0 ? void 0 : _b.end();
        (_c = this.errorLogStream) === null || _c === void 0 ? void 0 : _c.end();
    }
    writeToAllStreams(message, customFatalLog) {
        var _a, _b, _c;
        if (this.fileProperties.enableLatestLog)
            (_a = this.latestFileStream) === null || _a === void 0 ? void 0 : _a.write(message);
        if (this.fileProperties.enableDebugLog)
            (_b = this.debugLogStream) === null || _b === void 0 ? void 0 : _b.write(message);
        if (this.fileProperties.enableErrorLog)
            (_c = this.errorLogStream) === null || _c === void 0 ? void 0 : _c.write(message);
        if (this.fileProperties.enableFatalLog && customFatalLog) {
            // create a new stream for fatal log
            // 4 random alphanumeric characters
            const uniqueId = Math.random().toString(36).substring(2, 6);
            const fatalLogStream = fs_1.default.createWriteStream(path_1.default.join(this.fileProperties.logFolderPath, 'fatal-crash', `fatal-${uniqueId}-${this.getTime(true, true)}.${this.fileProperties.generateHTMLLog ? 'html' : 'log'}`));
            fatalLogStream.write(this.defaultHeader);
            fatalLogStream.end(customFatalLog);
        }
    }
    compressLastSessionLogs() {
        if (!this.fileProperties.compressLogFilesAfterNewExecution)
            return;
        const zip = new adm_zip_1.default();
        var files = fs_1.default.readdirSync(this.fileProperties.logFolderPath);
        // const fatalCrashFiles = fs.readdirSync(Path.join(this.fileProperties.logFolderPath, 'fatal-crash'));
        const latestLogsFiles = fs_1.default.readdirSync(path_1.default.join(this.fileProperties.logFolderPath, 'latestLogs'));
        // files = files.concat(fatalCrashFiles.map((file) => Path.join('fatal-crash', file)));
        files = files.concat(latestLogsFiles.map((file) => path_1.default.join('latestLogs', file)));
        // use fs.stat on latest.log/html to get its last modified date
        const latestLogPath = path_1.default.join(this.fileProperties.logFolderPath, `latest.${this.fileProperties.generateHTMLLog ? 'html' : 'log'}`);
        const latestLogStats = fs_1.default.statSync(latestLogPath);
        // get mtime and replace : with - to avoid windows file system errors
        const latestLogDate = latestLogStats.mtime.toISOString().replace(/:/g, '-').split('.')[0];
        files.forEach((file) => {
            if (file.endsWith('.log') || file.endsWith('.html')) {
                zip.addLocalFile(path_1.default.join(this.fileProperties.logFolderPath, file));
                // don't delete fatal-crash logs
                if (!file.startsWith('fatal'))
                    fs_1.default.unlinkSync(path_1.default.join(this.fileProperties.logFolderPath, file));
            }
        });
        const uniqueId = Math.random().toString(36).substring(2, 6);
        fs_1.default.writeFileSync(path_1.default.resolve(this.fileProperties.logFolderPath, `logs-${uniqueId}-${latestLogDate}.zip`), zip.toBuffer());
    }
    getFormattedPrefix() {
        var prefix = '';
        prefix += chalk_1.default.hex('#5c5c5c')('[');
        prefix += chalk_1.default.gray(this.prefix);
        prefix += chalk_1.default.hex('#5c5c5c')(']');
        return this.prefix !== '' ? prefix : '';
    }
    getTime(fullDate, friendlySymbols) {
        const time = new Date(Date.now());
        const day = time.getDate() < 10 ? '0' + time.getDate() : time.getDate();
        const month = time.getMonth() < 10 ? '0' + time.getMonth() : time.getMonth();
        const year = time.getFullYear();
        const seconds = time.getSeconds() < 10 ? '0' + time.getSeconds() : time.getSeconds();
        const minutes = time.getMinutes() < 10 ? '0' + time.getMinutes() : time.getMinutes();
        const hours = time.getHours() < 10 ? '0' + time.getHours() : time.getHours();
        // eslint-disable-next-line max-len
        return `${friendlySymbols ? '' : '['}${fullDate ? day : ''}${fullDate ? (friendlySymbols ? '-' : ':') : ''}${fullDate ? month : ''}${fullDate ? (friendlySymbols ? '-' : ':') : ''}${fullDate ? year : ''}${fullDate ? (friendlySymbols ? 'T' : '-') : ''}${hours}${friendlySymbols ? '-' : ':'}${minutes}${friendlySymbols ? '-' : ':'}${seconds}${friendlySymbols ? '' : ']'}`;
    }
    generateMessagePrefix(level) {
        const fgColor = [interfaces_1.ELoggerLevelBaseColors[level], interfaces_1.ELoggerLevelAlternateColors[level]];
        var time = chalk_1.default.hex(fgColor[Number(this.coloredBackground)])(this.getTime() + ' ');
        var prefix = chalk_1.default.hex(fgColor[Number(this.coloredBackground)])(this.getFormattedPrefix() + ' ');
        var levelText = chalk_1.default.hex(fgColor[Number(this.coloredBackground)])(interfaces_1.ELoggerLevelNames[level].toUpperCase() + ':');
        if (this.coloredBackground) {
            time = chalk_1.default.bgHex(interfaces_1.ELoggerLevelBaseColors[level])(time);
            prefix = chalk_1.default.bgHex(interfaces_1.ELoggerLevelBaseColors[level])(prefix);
            levelText = chalk_1.default.bgHex(interfaces_1.ELoggerLevelBaseColors[level])(levelText);
        }
        return {
            coloredMessagePrefix: `${time}${prefix}${levelText}`,
            rawMessagePrefix: `${this.getTime()} [${this.prefix}] ${interfaces_1.ELoggerLevelNames[level].toUpperCase()}:`,
            textColor: fgColor[Number(this.coloredBackground)],
        };
    }
    log(text, levelToLog, ...args) {
        var _a, _b, _c;
        const level = levelToLog !== null && levelToLog !== void 0 ? levelToLog : this.defaultLevel;
        if (text instanceof Error) {
            text = text.toString();
        }
        text = util_1.default.format(text, ...args);
        if (level === interfaces_1.ELoggerLevel.FATAL)
            return this.fatal(text, ...args);
        const consoleLevels = {
            [interfaces_1.ELoggerLevel.INFO]: console.log,
            [interfaces_1.ELoggerLevel.WARN]: console.warn,
            [interfaces_1.ELoggerLevel.ERROR]: console.error,
            [interfaces_1.ELoggerLevel.DEBUG]: console.debug,
        };
        const { coloredMessagePrefix, rawMessagePrefix, textColor } = this.generateMessagePrefix(level);
        const messageToConsole = (this.coloredBackground && this.allLineColored)
            ? chalk_1.default.bgHex(interfaces_1.ELoggerLevelBaseColors[level])(chalk_1.default.hex(interfaces_1.ELoggerLevelAlternateColors[level])(' ' + text))
            : (this.allLineColored ? chalk_1.default.hex(interfaces_1.ELoggerLevelBaseColors[level])(' ' + text) : ' ' + text);
        if ((this.debugActive && level === interfaces_1.ELoggerLevel.DEBUG) || (level !== interfaces_1.ELoggerLevel.DEBUG)) {
            consoleLevels[level](coloredMessagePrefix + messageToConsole);
        }
        // escapes the text to a be secure to be used in html
        const escapedText = (0, escape_html_1.default)(text.toString());
        // eslint-disable-next-line max-len
        const textSpanElement = this.allLineColored ? `<span style="color: ${textColor}; ${this.coloredBackground ? 'background: ' + interfaces_1.ELoggerLevelBaseColors[level] : ''}">${escapedText}</span>` : `<span style="color: ${this.htmlTextColor}; background: ${this.htmlBackgroundColor};">${escapedText}</span>`;
        // eslint-disable-next-line max-len
        const parentSpanElement = `<span style="color: ${textColor}; ${this.coloredBackground ? 'background: ' + interfaces_1.ELoggerLevelBaseColors[level] + ';' : ''}${(this.allLineColored && this.coloredBackground) ? '--txtBackground: ' + interfaces_1.ELoggerLevelBaseColors[level] + ';' : ''}"><span class='pre'>${rawMessagePrefix}&nbsp;</span>${textSpanElement}</span>\n`;
        if (this.fileProperties.enableDebugLog) {
            (_a = this.debugLogStream) === null || _a === void 0 ? void 0 : _a.write(this.fileProperties.generateHTMLLog ? parentSpanElement : (rawMessagePrefix + ' ' + text + '\n'));
        }
        if (this.fileProperties.enableErrorLog && level === interfaces_1.ELoggerLevel.ERROR) {
            // eslint-disable-next-line max-len
            (_b = this.errorLogStream) === null || _b === void 0 ? void 0 : _b.write(this.fileProperties.generateHTMLLog ? parentSpanElement : (rawMessagePrefix + ' ' + text + '\n'));
        }
        if (this.fileProperties.enableLatestLog && level !== interfaces_1.ELoggerLevel.DEBUG) {
            (_c = this.latestFileStream) === null || _c === void 0 ? void 0 : _c.write(this.fileProperties.generateHTMLLog ? parentSpanElement : (rawMessagePrefix + ' ' + text + '\n'));
        }
    }
    info(text, ...args) {
        this.log(text, interfaces_1.ELoggerLevel.INFO, ...args);
    }
    warn(text, ...args) {
        this.log(text, interfaces_1.ELoggerLevel.WARN, ...args);
    }
    error(text, ...args) {
        this.log(text, interfaces_1.ELoggerLevel.ERROR, ...args);
    }
    debug(text, ...args) {
        this.log(text, interfaces_1.ELoggerLevel.DEBUG, ...args);
    }
    fatal(text, ...args) {
        var _a, _b;
        var message = text.toString();
        var stack = [];
        var fullString = text.toString();
        if (text instanceof Error) {
            stack = (_a = text.stack) === null || _a === void 0 ? void 0 : _a.split('\n');
            if (stack) {
                fullString = stack.join('\n');
                message = (_b = stack.shift()) !== null && _b !== void 0 ? _b : '';
            }
        }
        message = util_1.default.format(message, ...args);
        const time = this.getTime();
        const prefix = this.getFormattedPrefix();
        const levelMsg = text.toString().startsWith('Error') ? interfaces_1.ELoggerLevelNames[3] : `${interfaces_1.ELoggerLevelNames[3]} ${interfaces_1.ELoggerLevelNames[2]}:`;
        message = `${time} ${prefix} ${levelMsg} ${message.toString()}${stack ? '\n' + stack.join('\n') : ''}`;
        const msg = chalk_1.default.bgWhite(chalk_1.default.redBright(message));
        var escapedFullText = (0, escape_html_1.default)(fullString);
        const escapedText = (0, escape_html_1.default)(text.toString());
        // convert tabs to html
        escapedFullText = escapedFullText.replace(/\t/g, '&nbsp;&nbsp;&nbsp;&nbsp;');
        escapedFullText = escapedFullText.replace(/ /g, '&nbsp;');
        const splitFullEscapedText = escapedFullText.split('\n');
        const htmlFullText = '<span>' + splitFullEscapedText.join('</span><span>') + '</span>';
        const textSpan = `<span style="color: ${interfaces_1.ELoggerLevelAlternateColors[3]}; background: ${interfaces_1.ELoggerLevelBaseColors[3]};">${escapedText}</span>`;
        const fullSpan = `<span style="color: ${interfaces_1.ELoggerLevelAlternateColors[3]}; background: ${interfaces_1.ELoggerLevelBaseColors[3]};">${htmlFullText}</span>`;
        // eslint-disable-next-line max-len
        const prefixSpan = `<span style="color: ${interfaces_1.ELoggerLevelAlternateColors[3]}; background: ${interfaces_1.ELoggerLevelBaseColors[3]};--txtBackground: ${interfaces_1.ELoggerLevelBaseColors[3]};"><span class='pre'>${time} [${this.prefix}] ${levelMsg}&nbsp;</span>${textSpan}</span>\n`;
        // eslint-disable-next-line max-len
        const fullPrefixSpan = `<span style="color: ${interfaces_1.ELoggerLevelAlternateColors[3]}; background: ${interfaces_1.ELoggerLevelBaseColors[3]};--txtBackground: ${interfaces_1.ELoggerLevelBaseColors[3]};"><span class='pre'>${time} [${this.prefix}] ${levelMsg}&nbsp;</span>${fullSpan}</span>\n`;
        // eslint-disable-next-line max-len
        const finalMessage = (this.fileProperties.generateHTMLLog ? prefixSpan : (time + ' [' + this.prefix + '] ' + levelMsg + ' ' + text + '\n')) + 'Please check the fatal log file for more details.\n';
        const finalFatalMessage = this.fileProperties.generateHTMLLog ? fullPrefixSpan : (time + ' [' + this.prefix + '] ' + levelMsg + ' ' + fullString + '\n');
        if (this.disableFatalCrash) {
            this.writeToAllStreams(finalMessage, finalFatalMessage);
        }
        else {
            this.closeFileStreams(finalMessage, finalFatalMessage);
        }
        console.error(msg);
        if (!this.disableFatalCrash) {
            process.exit(5);
        }
    }
}
exports.Logger = Logger;
