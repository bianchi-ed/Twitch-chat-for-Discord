"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseFinalMessage = exports.parseMessage = exports.parseSource = exports.parseCommand = exports.parseTags = void 0;
// https://dev.twitch.tv/docs/irc/example-parser
/**
 * @private
 */
function parseTags(tags) {
    const tagsToIgnore = {
        'client-nonce': null,
        flags: null,
    };
    const dictParsedTags = {};
    const parsedTags = tags.split(';');
    parsedTags.forEach(tag => {
        var _a;
        const parsedTag = tag.split('=');
        const tagValue = (_a = parsedTag[1]) !== null && _a !== void 0 ? _a : null;
        switch (parsedTag[0]) {
            case 'badges':
            case 'badge-info':
                if (tagValue) {
                    const dict = {};
                    const badges = tagValue.split(',');
                    badges.forEach(pair => {
                        const badgeParts = pair.split('/');
                        dict[badgeParts[0]] = badgeParts[1];
                    });
                    dictParsedTags[parsedTag[0]] = dict;
                }
                else {
                    dictParsedTags[parsedTag[0]] = null;
                }
                break;
            case 'emotes':
                if (tagValue) {
                    const dictEmotes = {};
                    const emotes = tagValue.split('/');
                    emotes.forEach(emote => {
                        const emoteParts = emote.split(':');
                        const textPositions = [];
                        const positions = emoteParts[1].split(',');
                        positions.forEach(position => {
                            const positionParts = position.split('-');
                            textPositions.push({
                                startPosition: positionParts[0],
                                endPosition: positionParts[1],
                            });
                        });
                        dictEmotes[emoteParts[0]] = textPositions;
                    });
                    dictParsedTags[parsedTag[0]] = dictEmotes;
                }
                else {
                    dictParsedTags[parsedTag[0]] = null;
                }
                break;
            case 'emote-sets':
                dictParsedTags[parsedTag[0]] = tagValue.split(',');
                break;
            default:
                if (!tagsToIgnore.hasOwnProperty(parsedTag[0])) {
                    dictParsedTags[parsedTag[0]] = tagValue;
                }
                break;
        }
    });
    return dictParsedTags;
}
exports.parseTags = parseTags;
/**
 * @private
 */
function parseCommand(rawCommandComponent) {
    let parsedCommand = null;
    var commandParts = rawCommandComponent.split(' ');
    switch (commandParts[0]) {
        case 'JOIN':
        case 'PART':
        case 'NOTICE':
        case 'CLEARCHAT':
        case 'HOSTTARGET':
        case 'PRIVMSG':
        case 'USERSTATE':
        case 'ROOMSTATE':
        case '001':
            parsedCommand = {
                command: commandParts[0],
                channel: commandParts[1],
            };
            break;
        case 'CAP':
            parsedCommand = {
                command: commandParts[0],
                isCapRequestEnabled: commandParts[2] === 'ACK',
            };
            break;
        default:
            parsedCommand = {
                command: commandParts[0],
            };
            break;
    }
    return parsedCommand;
}
exports.parseCommand = parseCommand;
/**
 * @private
 */
function parseSource(rawSourceComponent) {
    var _a;
    if (rawSourceComponent != null) {
        const sourceParts = rawSourceComponent.split('!');
        return {
            host: (_a = sourceParts[1]) !== null && _a !== void 0 ? _a : sourceParts[0],
            nick: sourceParts[1] ? sourceParts[0] : null,
        };
    }
    return null;
}
exports.parseSource = parseSource;
/**
 * @private
 */
function parseMessage(message) {
    const parsedMessage = {
        tags: null,
        source: null,
        command: null,
        parameters: null,
    };
    let idx = 0;
    let rawTagsComponent = null;
    let rawSourceComponent = null;
    let rawCommandComponent = null;
    let rawParametersComponent = null;
    if (message[idx] === '@') {
        const endIdx = message.indexOf(' ');
        rawTagsComponent = message.slice(1, endIdx);
        idx = endIdx + 1;
    }
    if (message[idx] === ':') {
        idx += 1;
        const endIdx = message.indexOf(' ', idx);
        rawSourceComponent = message.slice(idx, endIdx);
        idx = endIdx + 1;
    }
    let endIdx = message.indexOf(':', idx);
    if (endIdx === -1) {
        endIdx = message.length;
    }
    rawCommandComponent = message.slice(idx, endIdx).trim();
    if (endIdx !== message.length) {
        idx = endIdx + 1;
        rawParametersComponent = message.slice(idx);
    }
    parsedMessage.command = parseCommand(rawCommandComponent);
    if (parsedMessage.command === null) {
        return null;
    }
    else {
        if (rawTagsComponent !== null) {
            parsedMessage.tags = parseTags(rawTagsComponent);
        }
        parsedMessage.source = parseSource(rawSourceComponent);
        parsedMessage.parameters = rawParametersComponent;
    }
    return parsedMessage;
}
exports.parseMessage = parseMessage;
/**
 * @private
 */
function parseFinalMessage(client, message) {
    var _a, _b;
    const channel = client.channels.get(message.command.channel);
    const id = (_a = message.tags.id) !== null && _a !== void 0 ? _a : null;
    const parsedMessage = {
        content: message.parameters,
        id,
        tags: message.tags,
        bits: (_b = parseInt(message.tags.bits)) !== null && _b !== void 0 ? _b : 0,
        channel,
        reply: (message) => {
            return new Promise((resolve, reject) => {
                if (!message || message.length === 0) {
                    client.getLogger().warn('Cannot send empty messages');
                    return reject('Cannot send empty messages');
                }
                else if (client.isAnonymous) {
                    client.getLogger().warn('Cannot send messages in anonymous mode!');
                    return reject('Cannot send messages in anonymous mode!');
                }
                client.getWebSocketManager().getConnection().send(`@reply-parent-msg-id=${id} PRIVMSG #${channel.name} :${message}`);
                return resolve();
            });
        },
        author: client.channels.get(message.command.channel).users.get(message.source.nick),
        toString() {
            return this.content;
        },
    };
    return parsedMessage;
}
exports.parseFinalMessage = parseFinalMessage;
