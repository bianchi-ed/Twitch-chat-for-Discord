"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Client = void 0;
const interfaces_1 = require("../interfaces/");
const managers_1 = require("./managers/");
const websocket_1 = require("./connection/websocket");
const rest_1 = require("./connection/rest");
const utils_1 = require("../utils");
const events_1 = __importDefault(require("events"));
class Client extends events_1.default {
    constructor(options) {
        super();
        this.isReady = false;
        this.readyAt = 0;
        this.currentStep = interfaces_1.ESteps.PRE_INIT;
        this.token = null;
        this.tokenVerified = false;
        this.isAnonymous = false;
        this.stepManagerStarted = false;
        this.restManager = new rest_1.RestManager(this);
        this.wsManager = new websocket_1.WebSocketManager(this);
        this.userManager = new managers_1.UserManager(this);
        this.channels = new managers_1.ChannelManager(this);
        this.resolveRunningStep = () => null;
        this.steps = {
            [interfaces_1.ESteps.PRE_INIT]: [
                () => __awaiter(this, void 0, void 0, function* () { yield this.setOptions(options); }),
                () => __awaiter(this, void 0, void 0, function* () { yield this.restManager.loadAllMethods(); }),
                () => __awaiter(this, void 0, void 0, function* () { yield this.wsManager.loadMethods(); }),
                () => { this.logger.debug('System is prepared, initializing...'); },
            ],
            [interfaces_1.ESteps.INIT]: [
                () => __awaiter(this, void 0, void 0, function* () { yield utils_1.waiters.waitForToken.bind(this)(); }),
            ],
            [interfaces_1.ESteps.POST_INIT]: [
                () => __awaiter(this, void 0, void 0, function* () { yield this.wsManager.start(); }),
            ],
            [interfaces_1.ESteps.LOGIN]: [
                () => __awaiter(this, void 0, void 0, function* () { yield this.wsManager.login(this.token); }),
                () => __awaiter(this, void 0, void 0, function* () { yield utils_1.waiters.waitForTwitchConnection.bind(this)(); }),
            ],
            [interfaces_1.ESteps.POST_LOGIN]: [
                () => __awaiter(this, void 0, void 0, function* () { yield this.multiJoin(this.options.channels); }),
            ],
            [interfaces_1.ESteps.READY]: [
                () => { this.readyAt = Date.now(); },
                () => { this.rawEmit('ready', this.options.ws.host, this.options.ws.port); },
            ],
            [interfaces_1.ESteps.RUNNING]: [
                () => __awaiter(this, void 0, void 0, function* () { return new Promise((resolve) => { this.resolveRunningStep = resolve; }); }),
            ],
            [interfaces_1.ESteps.STOPPING]: [
                () => __awaiter(this, void 0, void 0, function* () { yield this.wsManager.disconnect(); }),
            ],
            [interfaces_1.ESteps.STOPPED]: [
                () => { this.logger.debug('GoodBye! Hope to see you again. ðŸ˜Š'); },
            ],
        };
    }
    /**
     * @description Adds a callback function to be execured in a specific step of the client.
     * @param {ESteps} step - The step to wait for
     * @param {any} callback - The callback to execute when the step is reached
     */
    addStepCommand(step, callback) {
        if (!this.steps[step.toString()]) {
            this.steps[step.toString()] = [];
        }
        this.steps[step.toString()].push(() => __awaiter(this, void 0, void 0, function* () { yield callback(); }));
    }
    /**
     * @description Starts the step manager without log in twitch.
     * @returns {Promise<void>}
     */
    start() {
        return new Promise((resolve) => {
            this.stepManager();
            this.on('client.changedStepTo.INIT', () => {
                return resolve();
            });
        });
    }
    /**
     * @description Starts the step manager and log in twitch.
     * @param {?string} token - The token to use for the login
     * @returns {Promise<void>}
     */
    login(token) {
        return new Promise((resolve) => {
            this.token = token;
            this.tokenVerified = true;
            this.stepManager();
            this.on('client.changedStepTo.POST_LOGIN', () => {
                return resolve();
            });
        });
    }
    /**
     * @description Set the client options
     * @param {IClientOptions} options
     * @returns {Promise<void>}
     * @private
     */
    setOptions(options) {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            const [modifiedOptions, logger] = yield (0, utils_1.logOptions)(interfaces_1.defaultOptions, options);
            this.options = modifiedOptions;
            this.logger = logger;
            resolve();
        }));
    }
    /**
     * @description Returns the time bot is connected with twitch in milliseconds
     * @returns {Promise<number>}
     * @example
     * await Client.uptime()
     * @example
     * Client.uptime().then((time) => { })
     */
    uptime() {
        return __awaiter(this, void 0, void 0, function* () {
            return Promise.resolve(Math.max((Date.now() - this.readyAt), 0));
        });
    }
    /**
     * @description returns the client uptime in milliseconds
     * @returns {number} the number of milliseconds since the client is ready
     * @example
     * const uptime = Client.uptime();
     **/
    uptimeSync() {
        return Math.max((Date.now() - this.readyAt), 0);
    }
    /**
     * @description Do a ping to twitch and returns the response time in milliseconds
     * @returns {Promise<number>} - The twitch response time in milliseconds
     */
    ping() {
        return __awaiter(this, void 0, void 0, function* () {
            const currentTimestamp = Date.now();
            yield this.wsManager.ping();
            return Promise.resolve(Date.now() - currentTimestamp);
        });
    }
    /**
     * @description Connects with a twitch channel chat
     * @param {string} channel - The channel name who will be connected
     * @return {Promise<string>} - Resolved when successfully connect with channel
     */
    join(channel) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                if (channel.includes(' ')) {
                    this.logger.error('Channel name cannot include spaces: ' + channel);
                    return reject('Channel name cannot include spaces: ' + channel);
                }
                if (!channel.startsWith('#')) {
                    channel = '#' + channel;
                }
                if (this.channels.get(channel) && this.channels.get(channel).connected === true) {
                    this.logger.warn('Already connected with this channel!');
                    return reject('Already connected with this channel!');
                }
                this.logger.debug('Connecting to: ' + channel.toLowerCase());
                this.wsManager.getConnection().send(`JOIN ${channel.toLowerCase()}`);
                const timeout = setTimeout(() => {
                    this.logger.error('Timeout while connecting to channel: ' + channel);
                    return reject('Timeout while connecting to channel: ' + channel);
                }, 10000);
                this.on('join', (joinedChannel) => {
                    if ('#' + joinedChannel.name === channel) {
                        clearTimeout(timeout);
                        return resolve(channel);
                    }
                });
            });
        });
    }
    /**
     * @description Connects in multiples twitch channels chats
     * @param {Array<string>} channels - The array of channels to join
     * @return {Promise<string>} - Resolved when successfully connect with channel
     */
    multiJoin(channels) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                if (channels.length === 0) {
                    this.logger.error('No channels to join!');
                    return reject('No channels to join!');
                }
                this.logger.debug('Connecting to: ' + channels.join(', ').toLowerCase());
                channels.forEach((channel, index) => {
                    if (channel.includes(' ')) {
                        this.logger.error('Channel name cannot include spaces: ' + channel);
                        return reject('Channel name cannot include spaces: ' + channel);
                    }
                    if (!channel.startsWith('#')) {
                        channels[index] = '#' + channel;
                    }
                });
                this.wsManager.getConnection().send(`JOIN ${channels.join(',').toLowerCase()}`);
                const timeouts = new Map();
                channels.forEach((channel) => {
                    timeouts.set(channel, setTimeout(() => {
                        this.logger.error('Timeout while connecting to channel: ' + channel);
                        channels.splice(channels.indexOf('#' + channel), 1);
                        timeouts.delete('#' + channel);
                        return reject('Timeout while connecting to channel: ' + channel);
                    }, 10000));
                });
                this.on('join', (joinedChannel) => {
                    if (channels.includes('#' + joinedChannel.name)) {
                        clearTimeout(timeouts.get('#' + joinedChannel.name));
                        channels.splice(channels.indexOf('#' + joinedChannel.name), 1);
                        timeouts.delete('#' + joinedChannel.name);
                    }
                    if (channels.length === 0) {
                        return resolve(channels.join(', ').toLowerCase());
                    }
                });
            }));
        });
    }
    /**
     * @description Disconnects from a twitch channel chat
     * @param {string} channel - The channel name who will be disconnected
     * @returns {Promise<string>} - Resolved with channel name when successfully disconnect with channel
     */
    leave(channel) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                if (channel.includes(' ')) {
                    this.logger.error('Channel name cannot include spaces: ' + channel);
                    return reject('Channel name cannot include spaces: ' + channel);
                }
                if (!channel.startsWith('#')) {
                    channel = '#' + channel;
                }
                if (this.user.username === channel)
                    return reject('You can\'t leave your own channel');
                this.logger.debug(`Leaving channel ${channel}`);
                if (this.channels.get(channel) && this.channels.get(channel).connected === false) {
                    this.logger.warn(`Already disconnected with ${channel} channel!`);
                    return reject(`Already disconnected with ${channel} channel!`);
                }
                this.logger.debug('Disconnecting from: ' + channel.toLowerCase());
                this.wsManager.getConnection().send(`PART ${channel.toLowerCase()}`);
                this.on('leave', (ch) => {
                    if (ch.name === channel.substring(1)) {
                        this.logger.debug(`Disconnected from ${channel}`);
                        resolve(channel);
                    }
                });
            });
        });
    }
    /**
     * @description Disconnects from twitch server and stop the client
     * @returns {Promise<void>}
     */
    disconnect() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve) => {
                this.resolveRunningStep();
                this.once('disconnected', () => {
                    return resolve();
                });
            });
        });
    }
    /**
     * @Override
     */
    emit(eventName, ...args) {
        this.getLogger().warn(`You are emitting an event as the client, this can lead to unexpected behaviors and its not recommend!\n
      We are still going to emit the event, but you should avoid it!`);
        return super.emit(eventName, ...args);
    }
    /**
     * @private
     */
    rawEmit(eventName, ...args) {
        return super.emit(eventName, ...args);
    }
    /**
     * @description Get the logger instance
     * @returns {Logger} [Logger] - The logger instance
     */
    getLogger() {
        return this.logger;
    }
    /**
     * @description Get the client options
     * @returns {IClientOptions} [IClientOptions] - The client options
     */
    getOptions() {
        return this.options;
    }
    /**
     * @description Get the REST API Manager Instance
     * @returns {RestManager} [RestManager] - The REST API Manager Instance
     */
    getRestManager() {
        return this.restManager;
    }
    /**
     * @description Get the WebSocket Manager Instance
     * @returns {WebSocketManager} [WebSocketManager] - The WebSocket Manager Instance
     * @public
     */
    getWebSocketManager() {
        return this.wsManager;
    }
    /**
     * @private
     */
    setIsReady(isReady) {
        if (this.isReady)
            return;
        this.isReady = isReady;
    }
    setStep(step) {
        var _a;
        if (step !== this.currentStep) {
            ((_a = this.logger) !== null && _a !== void 0 ? _a : console).debug(`Step changed from ${this.currentStep} to ${step}`);
        }
        this.currentStep = step;
        this.rawEmit('client.changedStep', step);
        this.rawEmit('client.changedStepTo.' + step);
    }
    /**
     * @description Get the current client step
     * @returns {ESteps} [ESteps] - The current client step
     */
    getCurrentStep() {
        return this.currentStep;
    }
    stepManager() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.stepManagerStarted)
                return;
            this.stepManagerStarted = true;
            for (const step in interfaces_1.ESteps) {
                this.setStep(step);
                if (this.steps[this.currentStep]) {
                    for (const stepFunction of this.steps[this.currentStep]) {
                        try {
                            // eslint-disable-next-line no-await-in-loop
                            yield stepFunction();
                        }
                        catch (error) {
                            this.logger.fatal(error);
                            return;
                        }
                    }
                }
            }
        });
    }
}
exports.Client = Client;
