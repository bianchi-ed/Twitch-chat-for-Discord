"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChannelManager = void 0;
const structures_1 = require("../../structures");
const collection_1 = require("@discordjs/collection");
class ChannelManager {
    constructor(client) {
        this.client = client;
        this.cache = new collection_1.Collection();
    }
    /**
     * @description Returns a channel from the cache
     * @param {string} channelName - The name of the channel
     * @returns {ChannelStructure} - The channel
     */
    get(channelName) {
        if (channelName.startsWith('#'))
            channelName = channelName.substring(1);
        return this.cache.get(channelName);
    }
    /**
     * @description Checks if a channel is in the cache
     * @param {string} channelName - The name of the channel
     * @returns {boolean} - If the channel exists in the cache returns true, else false
     */
    has(channelName) {
        if (channelName.startsWith('#'))
            channelName = channelName.substring(1);
        return this.cache.has(channelName);
    }
    /**
     * @description Sets a channel in the cache
     * @param {string} channelName - The name of the channel
     * @param {ChannelStructure} channel - The channel to set
     * @returns {Collection<string, ChannelStructure>} - The updated cache
     */
    set(channelName, channel) {
        this.cache.set(channelName, channel);
        return this.cache;
    }
    /**
     * @description Adds a channel to the cache
     * @param {string} channel - The name of the channel
     * @returns {Collection<string, ChannelStructure>} - The updated cache
     */
    addChannel(channel) {
        return this.set(channel.name, channel);
    }
    /**
     * @private
     */
    generateChannel(channelName) {
        if (channelName.startsWith('#'))
            channelName = channelName.substring(1);
        return new structures_1.ChannelStructure(this.client, channelName);
    }
    /**
     * @private
     */
    generateChannelFromTwitch(channelName, tags) {
        if (channelName.startsWith('#'))
            channelName = channelName.substring(1);
        const channelBase = new structures_1.ChannelStructure(this.client, channelName);
        return this.updateFromTags(channelBase, tags);
    }
    /**
     * @private
     */
    updateChannel(channelName, tags) {
        if (channelName.startsWith('#'))
            channelName = channelName.substring(1);
        if (!this.has(channelName)) {
            const newChannel = this.generateChannelFromTwitch(channelName, tags);
            this.addChannel(newChannel);
            return newChannel;
        }
        const channelOld = this.get(channelName);
        const channel = this.updateFromTags(channelOld, tags);
        this.set(channelName, channel);
        return channel;
    }
    updateFromTags(channel, tags) {
        channel.emoteOnly = tags['emote-only'] !== null ? tags['emote-only'] : channel.emoteOnly;
        channel.followersOnly = tags['followers-only'] !== null ? tags['followers-only'] >= 0 : channel.followersOnly;
        channel.followersCoolDown = tags['followers-only'] !== null ? tags['followers-only'] : channel.followersCoolDown;
        channel.r9k = tags.r9k !== null ? tags.r9k : channel.r9k;
        channel.rituals = tags.rituals !== null ? tags.rituals : channel.rituals;
        channel.id = tags['room-id'] !== null ? tags['room-id'] : channel.id;
        channel.slowMode = tags.slow !== null ? tags.slow >= 1 : channel.slowMode;
        channel.slowCoolDown = tags.slow !== null ? tags.slow : channel.slowCoolDown;
        channel.subsOnly = tags.subs !== null ? tags.subs : channel.subsOnly;
        return channel;
    }
}
exports.ChannelManager = ChannelManager;
