"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebSocketManager = void 0;
const utils_1 = require("../../../utils");
const ws = __importStar(require("ws"));
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
class WebSocketManager {
    constructor(client) {
        this.methods = {};
        this.username = 'TwitchJSV2';
        this.pingFailures = 0;
        this.methodsFolder = path_1.default.resolve(__dirname, 'methods');
        this.client = client;
        this.restManager = this.client.getRestManager();
        this.isAnonymous = null;
    }
    /**
     * @private
     */
    loadMethods() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                this.client.getLogger().debug('Loading WebSocket Methods...');
                const methods = fs_1.default.readdirSync(this.methodsFolder);
                for (const method of methods) {
                    if ((method.endsWith('.ts') || method.endsWith('.js')) && !method.includes('.d.ts')) {
                        this.client.getLogger().debug(`Loading WebSocket Method: ${method} ...`);
                        const methodName = method.replace(/(\.js)|(\.ts)/g, '').toLowerCase();
                        const loadedMethod = require(path_1.default.resolve(this.methodsFolder, method));
                        const newMethod = new loadedMethod.default(this.client);
                        // eslint-disable-next-line no-await-in-loop
                        const runConditions = yield newMethod.preLoad();
                        this.methods[methodName] = { method: newMethod, runConditions, execute: newMethod.execute.bind(newMethod) };
                        this.client.getLogger().debug(`Loaded WebSocket Method: ${methodName}!`);
                    }
                }
                this.client.getLogger().debug('Loaded ' + Object.keys(this.methods).length + ' WebSocket Methods!');
                resolve();
            }));
        });
    }
    /**
     * @private
     */
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                this.client.getLogger().debug('Starting WebSocket Manager...');
                const options = this.client.getOptions();
                this.connection = new ws.WebSocket(`${options.ws.type}://${options.ws.host}:${options.ws.port}`);
                this.connection.on('open', () => { this.onOpen(); resolve(); });
                this.connection.on('message', (data) => { this.onMessage(data.toString()); });
                this.connection.on('error', (err) => { this.onError(err); });
                this.connection.on('close', (code, reason) => { this.onClose(code, reason.toString()); });
            }));
        });
    }
    /**
     * @description Loggin twitch chat.
     * @param {?string} token - The token to use for the connection. If not provided or false, the client will log in as anonymous.
     * @returns {Promise<void>}
     */
    login(token) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                var continueLogin = true;
                this.client.getLogger().debug('Logging in...');
                if (token || 'CLIENT_TOKEN' in process.env) {
                    if (!token && 'CLIENT_TOKEN' in process.env)
                        token = process.env.CLIENT_TOKEN;
                    this.client.getLogger().debug('Validating token...');
                    if (!token.startsWith('oauth:')) {
                        if (token.includes(' '))
                            token = token.split(' ')[1];
                        this.client.getLogger().warn('Non-standard token provided, Token should look like "oauth:", adding "oauth:" and proceeding...');
                        token = `oauth:${token}`;
                    }
                    yield this.restManager.get('getTokenValidation', token)
                        .then((res) => __awaiter(this, void 0, void 0, function* () {
                        this.username = res.login.toString();
                        this.client.getLogger().debug(`Logging in as ${this.username}...`);
                        this.isAnonymous = false;
                        this.client.isAnonymous = false;
                        this.connection.send(`PASS ${token}`);
                        this.connection.send(`NICK ${this.username.toLowerCase()}`);
                    }))
                        // eslint-disable-next-line @typescript-eslint/no-unused-vars
                        .catch((ignored) => __awaiter(this, void 0, void 0, function* () {
                        this.client.getLogger().error('Invalid token provide!');
                        continueLogin = false;
                        return reject(new Error('Invalid token!'));
                    }));
                }
                else {
                    this.client.getLogger().debug('Logging in as anonymous...');
                    this.isAnonymous = true;
                    this.client.isAnonymous = true;
                    this.connection.send('PASS SCHMOOPIIE');
                    this.connection.send(`NICK justinfan${Math.floor(1000 + Math.random() * 9000)}`);
                }
                if (!continueLogin)
                    return;
                this.connection.send('CAP REQ :twitch.tv/tags twitch.tv/commands twitch.tv/membership');
                this.client.getLogger().debug('Logged in!');
                resolve();
            }));
        });
    }
    onOpen() {
        this.client.getLogger().debug('WebSocket connection opened!');
    }
    onMessage(message) {
        const splittedMessage = message.split('\r\n');
        for (const line of splittedMessage) {
            this.client.getLogger().debug('Received message: ' + line);
            const parsedMessage = utils_1.parser.parseMessage(line);
            if (this.methods[parsedMessage.command.command.toLowerCase()]) {
                const method = this.methods[parsedMessage.command.command.toLowerCase()];
                method.execute(parsedMessage);
            }
        }
    }
    onError(err) {
        this.client.getLogger().error('WebSocket error: ' + err.message);
    }
    onClose(code, reason) {
        this.client.rawEmit('websocket.closed', { code, reason });
        clearTimeout(this.pingLoopTimeout);
        clearInterval(this.pingLoopInterval);
        if (code === 1000)
            return this.client.getLogger().debug('WebSocket connection closed!');
        this.client.getLogger().error('WebSocket closed: ' + reason + '. With code: ' + code);
    }
    /**
     * @private
     */
    getConnection() {
        return this.connection;
    }
    /**
     * @private
     */
    pingLoop() {
        this.pingLoopInterval = setInterval(() => {
            this.connection.send('PING :tmi.twitch.tv');
            this.pingLoopTimeout = setTimeout(() => {
                this.pingFailures++;
                if (this.pingFailures >= 3) {
                    this.client.getLogger().error('Failed to ping twitch 3 times, disconnecting!');
                    this.disconnect(true);
                    clearTimeout(this.pingLoopTimeout);
                    clearInterval(this.pingLoopInterval);
                }
            }, 10000);
            this.client.on('pong', () => {
                this.pingFailures = 0;
                clearTimeout(this.pingLoopTimeout);
            });
        }, 60000);
    }
    /**
     * @description Do a ping to twitch.
     * @returns {Promise<void>}
     */
    ping() {
        return new Promise((resolve, reject) => {
            this.connection.send('PING :tmi.twitch.tv');
            const pingTimeout = setTimeout(() => {
                this.client.getLogger().error('Ping timeout!');
                reject(new Error('Ping timeout!'));
            }, 10000);
            this.client.on('pong', () => {
                clearTimeout(pingTimeout);
                resolve();
            });
        });
    }
    /**
     * @description Sends a message in the specified live chat
     * @param {string} channel - The channel to send the message to
     * @param {string[]} message - The message to send
     * @returns {Promise<void>} - Resolves when the message is sent
     */
    sendMessage(channel, ...message) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                if (typeof channel !== 'string') {
                    this.client.getLogger().warn('The channel must be a String');
                    return reject('The channel must be a String');
                }
                else if (!message || message.length === 0) {
                    this.client.getLogger().warn('Cannot send empty messages');
                    return reject('Cannot send empty messages');
                }
                else if (this.isAnonymous) {
                    this.client.getLogger().warn('Cannot send messages in anonymous mode!');
                    return reject('Cannot send messages in anonymous mode!');
                }
                else if (!channel.startsWith('#')) {
                    channel = '#' + channel;
                }
                this.connection.send(`PRIVMSG ${channel} :${message.join(' ')}`);
                return resolve();
            });
        });
    }
    /**
     * @description Disconnects from the twitch server
     * @param {boolean} bypass - Bypass security checks
     * @returns {Promise<void>}
     */
    disconnect(bypass = false) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                if (this.connection.readyState === this.connection.CLOSED)
                    return resolve();
                this.client.getLogger().debug('Disconnecting...');
                if (!bypass) {
                    this.client.getLogger().debug('Leaving all channels...');
                    const leavedChannels = [];
                    yield Promise.all(this.client.channels.cache.filter((channel) => { return channel.connected; }).map((channel) => __awaiter(this, void 0, void 0, function* () {
                        leavedChannels.push(channel.name);
                        return channel.leave().catch(() => null);
                    })));
                    this.client.getLogger().debug('Leaved channels: ' + leavedChannels.join(', '));
                }
                else
                    this.client.getLogger().warn('Bypassing channel leave...');
                this.client.getLogger().debug('Clearing timeouts...');
                clearTimeout(this.pingLoopTimeout);
                clearInterval(this.pingLoopInterval);
                this.client.getLogger().debug('Closing WebSocket connection...');
                if (!bypass)
                    this.connection.close(1000, 'Client disconnect');
                else {
                    this.connection.terminate();
                    this.client.getLogger().warn('Connection was destroyed!');
                }
                this.client.on('websocket.closed', ({ code, reason }) => {
                    this.client.getLogger().debug('Disconnected!');
                    this.client.getLogger().debug('WebSocket closed: ' + reason + '. With code: ' + code);
                    this.client.rawEmit('disconnected');
                    resolve();
                });
            }));
        });
    }
}
exports.WebSocketManager = WebSocketManager;
